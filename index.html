<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Monthly Art Vol.2 - Boiling Point: Emerging Artists & Spaces in Seoul</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- PageFlip -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip/dist/css/page-flip.min.css">
  <script src="https://cdn.jsdelivr.net/npm/page-flip/dist/js/page-flip.browser.min.js"></script>
  <style>
    :root{
      --bg:#0b0c10; --panel:#151821; --text:#e9eef6; --muted:#9aa3b2; --accent:#46b3ff; --paper-dark:#0e1117;
      /* JS에서 실제 값으로 덮어씌움: 단면폭/단면높이/스프레드폭 */
      --page-w:1240px; --page-h:1624px; --book-w:2480px;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0d1017,#0b0c10);color:var(--text);font-family:system-ui,"Noto Sans KR",sans-serif}
    .app{display:grid;grid-template-rows:auto 1fr auto;height:100%;gap:10px}
    .toolbar,.footer{background:#151821cc;backdrop-filter:blur(6px);padding:10px 12px;display:flex;align-items:center;gap:10px;border-block:1px solid #222938}
    .spacer{flex:1}
    .btn{border:1px solid #2a3143;background:#1a1f2c;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    .field{display:inline-flex;align-items:center;gap:6px;border:1px solid #2a3143;border-radius:10px;padding:6px 10px;background:#101522}
    .range{width:160px;accent-color:var(--accent)}
    .hint{color:var(--muted);font-size:13px}

    /* 뷰포트/줌 레이어 */
    #viewer{position:relative;display:grid;place-items:center;overflow:hidden;touch-action:none;background:transparent;}
    #zoomLayer{
      position:relative;width:fit-content;height:fit-content;
      transform-origin:0 0; cursor:grab; user-select:none; background:var(--paper-dark);
    }
    #zoomLayer.dragging{cursor:grabbing;}

    /* PageFlip 컨테이너: 스프레드(책 전체) 크기로 고정 */
    #flip{
      position:relative; width:var(--book-w); height:var(--page-h);
      transition:none; background:var(--paper-dark);
    }
    /* 내부 캔버스 배경도 어둡게 */
    .stf__canvas, .stf_canvas, #flip canvas { background:var(--paper-dark) !important; }

    input[type="number"]{width:70px;background:transparent;border:none;color:inherit;text-align:right;font-weight:700}
    #status{font-weight:600}
    /* 제목 박스: 한 줄 고정 + 말줄임표 + 최대 높이 35px  04:24pm 추가*/
    .titleBox{
      /* flex 레이아웃에서 ellipsis가 동작하도록 */
      min-width: 0;           /* 중요: 줄바꿈 대신 축소 허용 */
      max-width: clamp(160px, 45vw, 720px); /* 화면 폭에 따라 유연한 최대폭 */
      display: flex;
      align-items: center;
    
      /* 기존 .field에서 상속되는 padding/border 유지 */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    
      /* 높이 제한 */
      max-height: 35px;       /* 세로 35px 넘지 않음 */
    }
    
    /* 실제 텍스트: 말줄임표 + 가변 폰트크기 */
    .titleText{
      font-weight: 700;
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    
      /* 너무 좁을 때 자동으로 줄이는 기본 장치 */
      font-size: clamp(12px, 1.6vw, 16px);
      line-height: 1.1;
      min-width: 0;           /* flex 수축 허용 */
    }
    
    /* 툴바가 너무 빽빽해지면 버튼/입력도 살짝 줄이는 보조 규칙 (선택) */
    @media (max-width: 640px){
      .toolbar .btn, .toolbar .field { padding: 4px 8px; }
      .toolbar .range { width: 120px; }
    }
  </style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <div class="field titleBox"><span id="bookTitle" class="titleText">Boiling Point: Emerging Artists & Spaces in Korea</span></div>
    <div class="spacer"></div>
    <div id="status" class="hint">Loading…</div>

    <button id="prev" class="btn">◀ Prev</button>
    <div class="field">
      <span>Page</span>
      <input id="page" type="number" min="1" value="1">
      <span id="total">/ 0</span>
    </div>
    <button id="next" class="btn">Next ▶</button>

    <div class="field">
      <span>Zoom</span>
      <!-- 25% ~ 400% -->
      <input id="zoom" class="range" type="range" min="25" max="400" value="100">
      <span id="zoomLbl">100%</span>
    </div>

    <button id="fs" class="btn" title="전체화면">⛶ Full</button>
  </div>

  <div id="viewer">
    <div id="zoomLayer">
      <div id="flip"></div>
    </div>
  </div>

  <div class="footer" style="justify-content:space-between">
    <div class="hint">ⓒ Wolganmisool Publications, Inc. 2025 All Right Reserved.</div>
    <div class="hint"></div>
  </div>
</div>

<script>
  const DEFAULT_MANIFEST = "./manifest.json";
  const qp = new URLSearchParams(location.search);
  const manifestArg = qp.get("manifest") || DEFAULT_MANIFEST;

  const viewer = document.getElementById('viewer');
  const zoomLayer = document.getElementById('zoomLayer');
  const flipRoot = document.getElementById('flip');
  const bookTitleEl = document.getElementById('bookTitle');
  const prevBtn = document.getElementById('prev');
  const nextBtn = document.getElementById('next');
  const pageInput = document.getElementById('page');
  const totalEl = document.getElementById('total');
  const zoomRange = document.getElementById('zoom');
  const zoomLbl = document.getElementById('zoomLbl');
  const fsBtn = document.getElementById('fs');
  const statusEl = document.getElementById('status');

  let pageFlip = null;
  let currentPages = [];

  // 원본 단면 크기 (픽셀) — 첫 이미지로 자동 감지
  let PAGE_W = 1240, PAGE_H = 1624;
  let BOOK_W = PAGE_W * 2, BOOK_H = PAGE_H;

  // 줌/패닝 상태
  const MIN_SCALE = 0.25, MAX_SCALE = 4.0;
  let scale = 1, tx = 0, ty = 0;

  function setStatus(msg){ statusEl.textContent = msg; }
  function naturalSort(a,b){ const c = new Intl.Collator(undefined,{numeric:true,sensitivity:'base'}); return c.compare(a,b); }
  function toAbs(urlLike, baseHref){ try { return new URL(urlLike, baseHref).href; } catch { return urlLike; } }

  function applyCSSVars(){
    const root = document.documentElement;
    root.style.setProperty('--page-w', PAGE_W + 'px');
    root.style.setProperty('--page-h', PAGE_H + 'px');
    root.style.setProperty('--book-w', BOOK_W + 'px');
  }

  function getImageSize(url){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload = ()=>resolve({ w: img.naturalWidth, h: img.naturalHeight });
      img.onerror = reject;
      // CORS가 있으면 서버에서 이미지에 Access-Control-Allow-Origin 설정 필요
      img.src = url;
    });
  }

  function initFlip(imageURLs){
    flipRoot.innerHTML = '';
    if (pageFlip){ pageFlip.destroy(); pageFlip = null; }
    pageFlip = new St.PageFlip(flipRoot, {
      // 단면 기준 원본 픽셀 해상도로 고정 — stretch 금지
      width: PAGE_W,
      height: PAGE_H,
      size: "fixed",
      minWidth: PAGE_W, maxWidth: PAGE_W,   // 컨테이너가 늘어나며 흐트러지는 걸 방지
      minHeight: PAGE_H, maxHeight: PAGE_H,
      usePortrait: false,                   // 스프레드 고정
      showCover: true,
      maxShadowOpacity: .2,
      mobileScrollSupport: true,
      disableFlipByClick: false
    });
    pageFlip.loadFromImages(imageURLs);

    totalEl.textContent = `/ ${imageURLs.length}`;
    pageInput.min = 1; pageInput.max = imageURLs.length; pageInput.value = 1;
    pageFlip.on('flip', e => { pageInput.value = e.data + 1; });
  }

  async function fetchManifest(url){
    setStatus(`Fetching manifest: ${url}`);
    const res = await fetch(url, { cache: 'no-store' });
    if(!res.ok){ const msg = `HTTP ${res.status} ${res.statusText} (manifest)\nURL: ${res.url}`; setStatus(msg); throw new Error(msg); }
    try { return await res.json(); } catch(e){ setStatus('manifest JSON 파싱 실패'); throw e; }
  }
  function normalizeManifest(manifest, manifestUrl){
    if (Array.isArray(manifest)) {
      const pages = [...manifest].sort(naturalSort).map(p => toAbs(p, manifestUrl));
      return { title: 'Monthly Art – Flipbook', pages };
    }
    if (manifest && Array.isArray(manifest.pages)) {
      const base = manifest.base ? toAbs(manifest.base, manifestUrl) : manifestUrl;
      const pages = manifest.pages.map(p => toAbs(p, base)).sort(naturalSort);
      return { title: manifest.title || 'Monthly Art – Flipbook', pages };
    }
    throw new Error('지원하지 않는 manifest 형식입니다.');
  }

  // ===== Zoom / Pan =====
  function applyTransform(){
    zoomLayer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`;
    zoomRange.value = Math.round(scale * 100);
    zoomLbl.textContent = `${Math.round(scale * 100)}%`;
  }
  function centerWithinViewport(){
    const vw = viewer.clientWidth, vh = viewer.clientHeight;
    const scaledW = BOOK_W * scale;
    const scaledH = BOOK_H * scale;
    if (scaledW <= vw) tx = (vw - scaledW) / 2; else tx = Math.min(0, Math.max(tx, vw - scaledW));
    if (scaledH <= vh) ty = (vh - scaledH) / 2; else ty = Math.min(0, Math.max(ty, vh - scaledH));
  }
  function setScale(newScale, fx, fy){
    const rect = viewer.getBoundingClientRect();
    const cx = (fx !== undefined) ? fx : rect.width/2;
    const cy = (fy !== undefined) ? fy : rect.height/2;

    const prev = scale;
    const next = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));

    const px = (cx - tx) / prev;
    const py = (cy - ty) / prev;

    scale = next;
    tx = cx - px * scale;
    ty = cy - py * scale;

    centerWithinViewport();
    applyTransform();
  }
  function fitToViewportOr100(){
    const vw = viewer.clientWidth, vh = viewer.clientHeight;
    const fit = Math.min(vw / BOOK_W, vh / BOOK_H);
    // 보기 시작 시 화면보다 크면 '맞춤'으로 시작, 아니면 100%
    const startScale = Math.max(MIN_SCALE, Math.min(1, fit));
    setScale(startScale);
  }

  // 컨트롤
  prevBtn.addEventListener('click', ()=>pageFlip?.flipPrev());
  nextBtn.addEventListener('click', ()=>pageFlip?.flipNext());
  pageInput.addEventListener('change', ()=>{
    if(!pageFlip) return;
    const n = Math.max(1, Math.min(parseInt(pageInput.value||'1',10), pageFlip.getPageCount()));
    pageFlip.flip(n-1); pageInput.value = n;
  });
  zoomRange.addEventListener('input', ()=>{
    setScale(parseInt(zoomRange.value,10)/100);
  });
  fsBtn.addEventListener('click', ()=>{
    const el = viewer;
    if(!document.fullscreenElement){
      (el.requestFullscreen || el.webkitRequestFullscreen || document.documentElement.requestFullscreen).call(el);
    } else {
      (document.exitFullscreen || document.webkitExitFullscreen || document.cancelFullscreen).call(document);
    }
  });

  // 휠 줌
  viewer.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = viewer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const factor = (e.deltaY < 0) ? 1.12 : 0.89;
    setScale(scale * factor, x, y);
  }, { passive:false });

  // 패닝 + 핀치
  const pointers = new Map();
  let isDragging = false, dragLast = {x:0,y:0};
  let pinchStartDist = 0, pinchStartScale = 1, pinchPrevCenter = {x:0,y:0};

  function distance(a,b){ return Math.hypot(a.x-a.x + (b.x-a.x), a.y-a.y + (b.y-a.y)); } // safe inline
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function mid(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  viewer.addEventListener('pointerdown', (e)=>{
    if (scale > 1) e.stopPropagation();
    viewer.setPointerCapture(e.pointerId);
    const r = viewer.getBoundingClientRect();
    pointers.set(e.pointerId, { x:e.clientX - r.left, y:e.clientY - r.top });

    if (pointers.size === 1 && scale > 1){
      isDragging = true; zoomLayer.classList.add('dragging'); dragLast = pointers.get(e.pointerId);
    } else if (pointers.size === 2){
      const [p1,p2] = [...pointers.values()];
      pinchStartDist = dist(p1,p2); pinchStartScale = scale; pinchPrevCenter = mid(p1,p2);
    }
  });
  viewer.addEventListener('pointermove', (e)=>{
    if (!pointers.has(e.pointerId)) return;
    const r = viewer.getBoundingClientRect();
    pointers.set(e.pointerId, { x:e.clientX - r.left, y:e.clientY - r.top });

    if (pointers.size === 2){
      const [a,b] = [...pointers.values()];
      const d = Math.max(1, dist(a,b));
      const c = mid(a,b);
      const target = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * (d / pinchStartDist)));
      setScale(target, c.x, c.y);
      tx += (c.x - pinchPrevCenter.x); ty += (c.y - pinchPrevCenter.y);
      centerWithinViewport(); applyTransform();
      pinchPrevCenter = c; e.stopPropagation();
    } else if (isDragging && scale > 1){
      const cur = pointers.get(e.pointerId);
      tx += (cur.x - dragLast.x); ty += (cur.y - dragLast.y);
      dragLast = cur; centerWithinViewport(); applyTransform(); e.stopPropagation();
    }
  });
  function endPointer(e){
    if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
    if (pointers.size < 2) pinchStartDist = 0;
    if (pointers.size === 0){ isDragging = false; zoomLayer.classList.remove('dragging'); }
  }
  viewer.addEventListener('pointerup', endPointer);
  viewer.addEventListener('pointercancel', endPointer);
  viewer.addEventListener('pointerleave', endPointer);

  window.addEventListener('resize', ()=>{ centerWithinViewport(); applyTransform(); });

  // 초기 로드
  (async ()=>{
    try{
      const absManifestUrl = toAbs(manifestArg, location.href);
      const raw = await fetchManifest(absManifestUrl);
      const normalized = normalizeManifest(raw, absManifestUrl);

      bookTitleEl.textContent = normalized.title || 'Monthly Art – Flipbook';
      currentPages = normalized.pages;
      if (!currentPages.length){ setStatus('manifest에 페이지가 없습니다.'); return; }

      // 1) 첫 이미지 해상도를 기준으로 단면 크기 결정 → 스프레드 크기 계산
      const dim = await getImageSize(currentPages[0]);
      PAGE_W = dim.w; PAGE_H = dim.h; BOOK_W = PAGE_W * 2; BOOK_H = PAGE_H;
      applyCSSVars(); // CSS에 반영 (#flip 폭/높이 갱신)

      // 2) PageFlip을 원본 픽셀로 고정 생성(해상도 저하 방지)
      initFlip(currentPages);

      // 3) 가운데 정렬 및 초기 배율(화면에 맞춤 또는 100%)
      fitToViewportOr100();

      setStatus('Ready');
    }catch(e){
      console.error(e);
      setStatus('로드 오류: ' + (e.message || e));
    }
  })();

  // 우클릭 방지
  document.addEventListener('contextmenu', (e)=>{ e.preventDefault(); }, { capture:true });

   // 제목 텍스트를 박스 폭에 자동 맞춤 (최소 11px)
  function fitTitle() {
    const box = document.querySelector('.titleBox');
    const text = document.getElementById('bookTitle');
    if (!box || !text) return;

    // 초기값(클램프 상한)으로 리셋 후 점진 축소
    text.style.fontSize = ''; // CSS clamp 우선
    const style = getComputedStyle(text);
    let size = parseFloat(style.fontSize);
    const minSize = 11;

    // 박스 내부 가용 폭
    const available = box.clientWidth;

    // 너무 커서 넘치면 0.5px 단위로 줄임
    let guard = 100; // 무한루프 방지
    while (text.scrollWidth > available && size > minSize && guard-- > 0) {
      size = Math.max(minSize, size - 0.5);
      text.style.fontSize = size + 'px';
    }
    // 마지막 안전장치: 그래도 넘치면 ellipsis로 처리(기본 CSS가 담당)
  }

  // 초기 데이터 로드/제목 설정 후 호출
  function afterBookReady(){
    fitTitle();
  }

  // 기존 Ready 직후에 한 번 호출
  // setStatus('Ready'); 다음 줄 등 적당한 위치에 호출해도 됩니다.
  const _origSetStatus = setStatus;
  window.setStatus = function(msg){
    _origSetStatus(msg);
    if (msg === 'Ready') {
      // 레이아웃이 안정된 다음 프레임에 실행
      requestAnimationFrame(fitTitle);
    }
  };

  // 창 크기 변경 시 디바운스하여 재적용
  let _fitTimer = null;
  window.addEventListener('resize', () => {
    clearTimeout(_fitTimer);
    _fitTimer = setTimeout(fitTitle, 120);
  });  
</script>
</body>
</html>
